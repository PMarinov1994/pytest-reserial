# pytest-reserial

![build](https://github.com/bessman/pytest-reserial/actions/workflows/main.yml/badge.svg)
[![PyPI](https://img.shields.io/pypi/v/pytest-reserial.svg)](https://pypi.org/project/pytest-reserial/)
[![License](https://img.shields.io/pypi/l/pytest-reserial)](https://mit-license.org/)

Pytest plugin for recording and replaying serial port traffic during tests.

## Installation

`pip install pytest-reserial`

## Usage

1.  Write your tests as if they would run with the device connected.

2.  When your tests pass with the device connected, run `pytest --record` to record serial traffic 
    from the passing tests.

3.  Now you can disconnect the device and run your tests with `pytest --replay`.

A simple example:

```python
# my_serial_app.py
from serial import Serial

def my_serial_app():
    with Serial(port=/dev/ttyUSB0) as s:
        # When we send '1' to the device, it responds with '2'.
        s.write(b"\x01")
        return s.read()

# Just use the 'reserial' fixture!
def test_my_serial_app(reserial):
    assert my_serial_app() == b"\x02"
```

Version >=0.5.0 now also supports tcp connections. Client connections that use `socket.socket` for communication can use
the new fixture `retcp` to record and replay messages. The fixture takes a parameter with the ip address `ip:port`. When `--record` is
used the same address will be returned so that your client can connect to the real target. When `--replay` is used, the address will
be of a Test TCPServer, that will replay the recorded messages. Unlike reserial fixture, retcp does not mock in `--replay` mode.
This allows for testing binary executables where mocking is not possible.

```python
# my_tcp_app.py
import socket

def my_tcp_app(address: str):
    addr = address.split(":")
    with socket.socket() as s:
        s.connect((addr[0], addr[1]))
        s.sendall(b'\x01')
        return s.recv(1)

# Just use the 'retcp' fixture!
@pytest.mark.parametrize("retcp", ["localhost:12345"], indirect=True)
def test_my_tcp_app(retcp: str):
    assert my_serial_app(retcp) == b"\x02"
```

The new fixture records how many bytes are send and received in a new log file. Old `reserial` tests will work as before, while
new `reserial` tests will generate the new log information. `retcp` tests always require this new log information for `--replay`.

You can manually add `'t'` messages inside the new log structure to simulate delays in the communication. The value will be passed
to python's `time.sleep()` function. The following restrictions apply:

- `'t'` status must come AFTER `'w'` status or BEFORE `'r'` status
- Double `'t'` status is not allowed

Example sequance: `'w'` -> `'t'` -> `'r'`<br>
Example sequance: `'w'` -> `'t'` -> `'r'` -> `'t'` -> `'r'`

The new status log is a list of tuples (key-value pairs) where the key is the status and the value is an INTEGER (int). The
following keys are defined and DATA is the integer value:

- `w` - the client has send DATA. This is what the server expects to receive and will validate agains `tx`. Auto-generated by `--record`.
- `r` - the client has read DATA. This is what the server should send to the client (data comes from `rx`). Auto-generated by `--record`.
- `c` - the client has called the `close()` method on the underlaying connection. DATA is always -1 (unused). Auto-generated by `--record`.
- `t` - the server will wait DATA amount of seconds before performing the write. This value must be manually added by the user.

Next:

1.  Connect the device.
2.  Run `pytest my_serial_app.py` and verify that the test passes with the device connected.
3.  Run `pytest --record my_serial_app.py`. The test will run again, and the traffic will be recorded.
4.  Disconnect the device.
5.  Run `pytest --replay my_serial_app.py`. The test will pass!

The logged traffic will be stored as JSON Lines, with one file per test file and one line per test, in the same directory as your test files. The files will have the same names as the test files except with a .jsonl extension instead of .py. For example, if your project layout is:

```shell
├── src
│   ├── myproject
│   │   ├── ...
├── tests
│   ├── test_myproject.py
```

Then after running `pytest --record`, the tests/ directory will contain a new file, test_myproject.jsonl, containing the recorded serial traffic from the tests.

## Why

Have you ever tried to write tests for a program that talks to an external device over serial (like an Arduino or something)? You probably wrote the tests assuming that the device is question would always be connected when running the tests, right? And later you got bit by one or more of the pitfalls of that approach:

-   You wanted to run the tests when the device wasn't connected. Perhaps you were travelling, or
    someone had borrowed it. Whatever the reason, you found yourself unable to run the tests, and
    therefore unable to continue development, until you could connect the device again.

-   You made a change to your program, and one of your tests failed. So far so good, right? That's
    what tests are for, after all. Only, you can't figure out why the test is failing. You spend
    several hours trying to fix it, but eventually give up and revert your changes.
    But the test still fails.
    So you try another device, and sure enough, now it passes. Turns out, what you thought was a
    problem with your code was actually a hardware failure.

-   Some of the tests depend on the device being in a certain state, and some of the tests depend on
    the device being in *another* state. So you can't run the entire test suite all at once, instead
    being forced to stop it halfway through and mess with a bunch of wires and buttons before you can
    run the rest of the tests.
   
And then you asked yourself, 'How do I write my tests so that the device doesn't need to be connected?' You may have gone down the rabbit hole that is mocking, and then replaced large parts of pyserial with mock interfaces, and ultimately ended up with a test suite that was significantly more complex than the program it was meant to test.

With pytest-reserial, you don't have to worry about any of that. Just write your tests as if the device is always connected. Then, simply use the `reserial` fixture to record the serial traffic from passing tests, and replay it when the device isn't connected.

## Requirements

pytest-reserial depends on pytest and pyserial.

## Copyright

MIT License, (C) 2022 Alexander Bessman
